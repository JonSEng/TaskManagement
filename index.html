<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Taskmanagement by JonSEng</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Taskmanagement</h1>
        <h2>Real-time Task Management</h2>
        <a href="https://github.com/JonSEng/TaskManagement" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="what-is-tasker" class="anchor" href="#what-is-tasker" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is Tasker:</h1>

<p>Tasker is a real-time task management application for teams. One administrator opens up the Tasker web app, starts a project (such as setting up an event), and adds people to tasks. As the event progresses, there is bidirectional communication between the administrator on the web app and the workers (through the mobile phones texting or native app). 
The use case would be for organizations that have involve anywhere from 5 - 100 people. For instance, lets say the EECS department has to plan a hackathon. There are various tasks with various dependencies and lead times: food, contacting companies, registration, day of registration...etc.  The idea of Tasker is for an administrator to easily drag and drop people to different assignments, get status updates on it, and reassign people, contact people as needed.
For the administrator, instead of texting or calling all 100 people involved in planning it, the workers will update the administrator - instead of the admin polling, he get's interrupts in computer science terms.
For the workers, they get real-time updates to the task and know when they’ve been reassigned and can communicate to the admin without blocking the admin through a phone call or various unnecessary texts. 
By providing a streamlined interface for communication for the admin and workers, real time projects that require much coordination can go much more smoothly.</p>

<p>Screencast:
<a href="https://vimeo.com/126762817">https://vimeo.com/126762817</a></p>

<p>Link to the Heroku based project - it is for development so please don’t do anything destructive; it is very fragile right now:
<a href="http://task-management.herokuapp.com">http://task-management.herokuapp.com</a>
<a href="https://github.com/JonSEng/TaskManagement">https://github.com/JonSEng/TaskManagement</a></p>

<h1>
<a id="concise-change-log-of-some-of-the-progress-weve-made" class="anchor" href="#concise-change-log-of-some-of-the-progress-weve-made" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concise change log of some of the progress we’ve made:</h1>

<p>*Created the rails framework for the web page.
*Tasks have a leader, subtasks and notes.
*Created a working SQL database that manages and is the one source of truth for all projects and workers and status. 
*Implemented Google OAuth features so that different groups can sign in just with Google.
*Enabled some Single Web Page functionality so that updates are much smoother
*Texting communication has been set up and has rudimentary functionality
*Tasks are listed and separated by their state: To Do, In Progress, Done (completed)
*Workers schema, database and rails migrations have been implemented to be backwards compatible with older versions of the software.
*Task Templates are created so new projects can import a set of recurring tasks through a Task Template. 
*Projects can be created, archived and assigned an administrator.
*Seeds.rb has the seed data for the project so new git clones of the repository can quickly get this running
*70% code coverage from rspec created.
*much more...</p>

<h1>
<a id="specs-of-the-project" class="anchor" href="#specs-of-the-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>Specs of the project:</h1>

<p>*We use Ruby 2.0 + and had spent much time migrating it from 1.9.3 to use the latest gemsets and to keep certain functions from breaking
*Gemfile is the only requirement. Use bundle install to get the correct gems
*After some various testing we discovered there are various complications in terms of machine architecture dependencies and Rails. It takes quite a lot to get this set up properly (OpenSSL version mismatches, GCC versions, linker versions have to match, libv8 issues…etc.)
*Just run “rake” to start the server
*You can rune “make server” (created a Makefile to make setup easier) to easily set it up</p>

<h1>
<a id="concluding-thoughts-lessons-learned--improvements-for-future" class="anchor" href="#concluding-thoughts-lessons-learned--improvements-for-future" aria-hidden="true"><span class="octicon octicon-link"></span></a>Concluding thoughts, lessons learned &amp; improvements for future:</h1>

<p>For one, I realized during the architecting stage of Tasker, there were many decisions that were later found to be suboptimal. For instance we had notions of task and leader of a task. Then after we started building we added the notion of a sub-task but realized that there are no leaders or assignees for sub-tasks which is something we realized we wanted. But by then we had already set up our database schema and had a complicated set of database migrations that kept everything backwards compatible and it was too difficult to add the sub-task assignees at that point. </p>

<p>Another lessons learned is to build quickly but re-usably (namely modularly) because I will likely have to tear things down and rebuild. For example, we later wanted to incorporate the notion of “Groups” (think of it as an organization) and have workers that signed up for task sessions (think of it as an event you are leading) to be localized to each Group. But that actually requires rebuilding much of the architecture from group up. If we had spent more time coding in a modular and clean way, it would have been much easier to rebuilt significant portions of our app without resorting to hacky solutions only because the full / clean rebuilding would take too long.</p>

<p>The concept though I still do think addresses a niche need – real-time collaborative events or projects. The key is that real-time here suggests granularity to the second level so someone putting on a show or event that needs to be tight on schedule can rest assured that the tool was built also for that – something lacking in all other collaborative tasks management applications.</p>

<p>All in all, the project has come a long way. The change-log above is only a short list of all that has been implemented and I am looking forward to see what direction the real-time task management app, Tasker, will go.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/JonSEng/TaskManagement/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/JonSEng/TaskManagement/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/JonSEng/TaskManagement"></a> is maintained by <a href="https://github.com/JonSEng">JonSEng</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
